# OCP (Open-Closed Principle) - Nyitva-zárt alapelv

Feladat: Adott az OCP\Shapes\Program\MAF.EKE.OCP.ShapesDemo projekt. Ez egy konzolos alkalmazást valósít meg, ami egy megadott méretű négyzetlap területét számolja ki. Két feladatot kell megoldani. Az első, hogy ne csak négyzet, hanem téglalap területét is tudja kiszámolni. A második, hogy cseréljük le a felületet egy WinForm felületre és ne csak kiszámoljuk, hanem rajzoljuk is ki egy megadott koordinátára az adott alakzatot. Tartsuk be a már eddig begyakorolt elveket, valamint az OCP elvet. Fontos, hogy az eredeti kódot továbbfejlesztve, tesztvezérelten érjünk célba, hogy egyúttal gyakoroljuk a TDR fejlesztési módszert. Ez a módszer segítséget jelent régi rossz kódok rendberakásánál, úgy, hogy közben a kód minden egyes refaktorálás után működőképes marad.

***TDR = ugyanaz az elv mint a TDD esetében, de itt nem új igényekhez írunk tesztet, majd elégítjük azt ki kóddal, hanem refaktoráláshoz írunk tesztet és azt elégítjük ki kóddal. Fontos, hogy ha még nem létezik teszt a módosítandó részhez, akkor első lépésként megírjuk azt a tesztet, ami a jelenlegi, módosítandó kódrészletet fedi le. Vagyis bebiztosítjuk magunkat, hogy a refaktorálás nem fog semmit se tönkretenni. Törekedni kell a 100 százalékos teszt lefedettségre, de a refaktorálás részhez már valódi TDD szabályokat követünk, vagyis egyszerre csak egy igényt fogalmazunk meg teszt formájában, majd elégítjük ki.***

Ha nem boldogulunk a feladattal, akkor nézzük át az elkészített páldák forrásait:
 - A Library könyvtár MAF.EKE.OCP.Shapes projektje a logikai részt valósítja meg.
 - A Library könyvtár MAF.EKE.OCP.Shapes.Test projektje a logikai rész tesztelését valósítja meg.
 - A Program könyvtár MAF.EKE.OCP.ShapesDemo2 projektje a feladatot kielégítő projekt.

Mindenkinek jó gyakorlást!

Ha a TDR gyakorlása elsőre nem megy, akkor itt a segítség, ami lépésről-lépésre leír egy lehetséges megoldást.
A vázolt példa nagyon egyszerű. Egy négyzetlap területének kiszámítása nem okozhat gondot. Vagyis a program logikai része a végtelenségig egyszerű. Mégis amikor azt mondjuk, hogy tesztvezérelten írjuk át, hirtelen azt se fogjuk tudni, hogy mit is kell tenni. Ilyenkor dőljünk hátra és gondoljuk át a feladatot. Már megint össze van keveredve a felület és a logikai megvalósítás. Az elsődleges célunk az lesz, hogy szétválasszuk a felületet és a logikát. Ha ezt megtettük, akkor már foglalkozhatunk a logikai rész rendberakásával.
Lássuk a lépéseket:
 - Mivel az eredeti gyakorló példát nem szeretnénk felülírni, ezért a ShapesDemo projektet lemásoljuk ShapesDemo2 névre. A továbbiakban ezt a projektet kezdjük el refaktorálni.
 - Mivel tesztvezérelten akarjuk javítani, a következő lépés, hogy létrehozzuk a logikai rész teszteléséhez a tesztprojektet, MAF.EKE.OCP.Shapes.Test néven.
 - A teszt projekt referenciájához fel szeretnénk venni a tesztelendő projektet, de ilyen még nincs, ezért létrehozzuk a MAF.EKE.OCP.Shapes projektet. Ebben lesz majd a logikai rész megvalósítva.
TDD esetén most következne, az, hogy előidézzük a piros állapotot, vagyis megírjuk az első tesztünket, amit majd ki kell elégíteni. Itt sincs ez másképpen. De mit is akarunk? Akár új projekt, akár már létező refaktorálását végezzük, kell egy terv. Látnunk kell azt, hogy mit akarunk elérni. Mi most azt akarjuk első körben elérni, hogy a logikai részt leválasszuk a felületről. De mi a logikai rész? Azon szolgáltatások összesége, amik a felület részére információt szolgáltatnak. A mi esetünkben csak egy ilyen szolgáltatás van. Egy négyzet területének kiszámítása. *Akár egy, akár több szolgáltatást tartalmaz a felület, egyszerre mindig csak egy szolgáltatást választunk le, mert csak egy igényhez írhatunk tesztet egyszerre, különben nem tartjuk be a TDR szabályait.* Készítünk egy minimális tervet. Mivel négyzet számítás szolgáltatásról van szó, ezért a szolgáltatást egy Square osztályba tesszük és a szolgáltatást egy AreaCalculation függvényben publikáljuk ki. Fontos, hogy itt nem készíthetünk ettől nagyobb tervet, mert egyenlőre csak annyi a célunk, hogy a logikai részt leválasszuk a felületről úgy, hogy közben végig üzemképes kell maradjon a kód. Ha minden szolgáltatást így apránként emelünk át, akkor végig üzemképes marad a kód. Nem kapunk ugyan tiszta kódot, de leválasztjuk a logikai részt a felületről. Tehát a további lépések:
 - A teszt projektünkbe létrehozunk egy SquareTest teszt osztályt. Ebbe készítünk egy TestCreateSquare nevű teszt függvényt, ami kikényszeríti a Square osztály létezését. Ha megfuttatjuk a tesztet, akkor az sikertelen lesz, vagyis pirosak vagyunk.
 - A logikai projektbe elkészítjük a Square osztályt. Megfuttatjuk a tesztet. Zöldek vagyunk.
 - A következő lépés, hogy kényszerítsük ki az AreaCalculation függvény létezését. Megírjuk a tesztet, ami kikényszeríti a függvény létezését. Mivel a függvény nem létezik, ezért a projekt le se fordul, vagyis pirosak vagyunk.
 - Megírjuk a függvényt. Zöldek vagyunk.
 - A függvényünknek kell egy bemeneti paraméter, amiben az oldal hosszát adjuk meg. Az előbb megírt tesztünket javítjuk, úgy, hogy várjon paramétert a függvény. Ismét pirosak vagyunk.
 - Kielégítjük az előbbi tesztet. Zöldek vagyunk.
 - A tesztünket ismét átírjuk, hogy kényszerítsen ki egy double típusú visszatérési értéket. Pirosak vagyunk.
 - Átírjuk a függvényünket, hogy adjon vissza egy darab 0-át. Zöldek vagyunk.
 - A következő lépés, hogy elvárjuk a függvényünk a megfelelő értéket adja vissza. Ehhez a tesztünket átírjuk, hogy egy, kettő és tíz paraméterekkel meghívva a függvényünket a megfelelő értéket, vagyis a helyes terület érték visszaadását várja el a függvénytől. 
 - Nincs más hátra, mint a valódi területszámító logikai részt átmásolni a felület kódjából a függvényünkbe. Az így kiszámolt értéket adja vissza a függvény. Ismét zöldek vagyunk.
Azt mondhatnánk, hogy megvagyunk a szolgáltatásokkal, de nem szabad elfelejteni, hogy szélsőértékeket is tesztelnünk kell. Szélsőérték lehetne a 0, de azzal nincs gond, mert 0\*0 az 0. Ettől függetlenül betehetjük. Itt a szélsőértékekkel a túlcsordulást kéne ellenőrizzük. Pl. double.Max paraméterrel hívva a függvény túlcsordulást eredményezne, de jelenleg a túlcsordulást a függvényünk nem kezeli. Amennyiben például int vagy uint értékeket használtunk volna, akkor a checked kulcsszóval védett részbe kellene tegyük a számításokat, így viszont egyszerűen Infinity értéket kapunk, de ez nekünk továbbra se jó. A következő lépésekkel kivédjük ezt:
 - Készítünk egy TestAreaCalculationOverflowError nevű teszt függvényt, ahol elvárjuk azt, hogy double.Max paraméterrel hívva a függvény hibát dobjon.
 - Megírjuk a kódot, hogy ismét zöldek legyünk.
 - Mivel zavar minket a túlcsordulás hibaüzenet, ezért átírjuk az előbbi tesztet úgy, hogy saját hibaosztály dobását várja.
 - Megírjuk a hibaosztályt és javítjuk a függvényünket úgy, hogy elkapjuk a hibát és saját hiba típussal dobjuk tovább. Figyelem! Itt most két lépést hajtottunk végre. Hiba osztályt írtunk és függvényt módosítottunk. *Én azt a szabályt alkalmazom, hogy ha egyedi hibaosztály készítésére van szükség, akkor azt mindig abban a lépésben teszem meg, ahol először szükséges az adott hibaosztály felhasználása, de csak akkor, ha a hibaosztály nem csinál mást mint meghívja az ősét. Ha nem csak ennyit csinál, hanem más műveleteket is végrehajt, akkor ezt az osztályt is a TDD módszer szerint kell lefejleszteni.* Itt most mondhatnánk azt, hogy ezzel megszegtük a TDD módszert. Igen, megszegtük. Viszont az esetek 99.9 százalékában ezek a hibaosztályok másra nem lesznek használva, vagyis nem lesznek módosítva, így fölösleges ezeket teszttel lefedni (nincs is mit tesztelni ilyenkor, hacsak nem a puszta létezését az osztálynak és a függvényeknek).
A logikai részt kiszerveztük, már csak az van hátra, hogy a felületet is átírjuk, hogy a Square osztályból vegye az információkat. Mielőtt ezt megtennénk előtte még van egy elmaradásunk. A függvényünk kész, már működik, de a felülethez nem készítettük el az Intellisense támogatását. Ezt pótoljuk. A következő lépések tehát:
 - Az AreaCalculation függvényhez a megfelelő komment elkészítése.
 - Az MAF.EKE.OCP.ShapesDemo2 projekt referenciájához hozzáadjuk a MAF.EKE.OCP.Shapes projektet.
 - A konzolos programban a négyzetlap terület számítása előtt példányosítjuk a Square osztályt és a terület kiíráshoz az AreaCalculation függvényt használjuk fel.
Ha lennének még logikai részt megvalósító kódok a konzolos alkalmazás felületén, akkor ismét kiválasztanánk egy szolgáltatást és kiemelnék a felületről, hasonlóan mint az előbbi területszámítást. Mivel itt nincs több logikai rész, így nem kell több szolgáltatást kiemelni. 
A logikai részt megvalósító kód így nézne ki ha csak egész számokkal dolgoznánk:
```csharp
    public class Square
{
public const string C_OverflowError = "Az oldal mérete túl nagy, a kiszámítása nem lehetséges!";

/// <summary>Négyzet területének kiszámítása.</summary>
/// <param name="pSideA">Az egyik oldal relatív mérete.</param>
/// <returns>A négyzet relatív területe.</returns>
public uint AreaCalculation(uint pSideA)
{
try
{
return checked(pSideA * pSideA);
}
catch(OverflowException ex)
{
throw new SquareException(C_OverflowError, ex);
}
}
}
```
Elmondhatjuk tehát, hogy szétválasztottuk a felületet a logikai résztől. Azt viszont nem mondhatjuk el, hogy tiszta kódunk van és még a feladatokat se oldottuk meg. A következő lépés lehetne az, hogy nekiesünk a feladat megoldásának, de mivel az is cél volt, hogy betartsuk az elveket, *sokkal könnyebb dolgunk lesz, ha előbb a kialakult kódhalmazt átírjuk úgy, hogy a kért elveket betartsák*. Szerencsére a példánk most annyira egyszerű, hogy itt nem lesz sok dolgunk. Lássuk:
 - GOF1 - Felületre programozz, ne implementációra! Ezt az elvet nem sértettük meg, ezzel nincs több feladatunk.
 - GOF2 - Használj objektum-összetételt öröklés helyett, ha csak lehet! Ezt az elvet se sértjük. Bár használunk egy esetben öröklődést, a SquareException esetében, de ezt célszerű így megírjuk, mivel gyakorlatilag ilyen esetekben csak becsomagolunk egy elkapott hibát egy saját hiba típusba.
 - SRP - Egy felelősség egy osztály alapelve. Jelenleg ezt se sértjük, mert az osztályunk egy felelősségi körrel rendelkezik és az igényelt szolgáltatást teljes egészében megvalósítja.
 - OCP - Nyitva-zárt alapelv. Látszólag ebben a példában ezt se sértjük, pedig ha jobban átgondoljuk, súlyosan megsértettük ezt az elvet. Ha megpróbálnánk a feladat első pontját teljesíteni, akkor vagy írnunk kéne egy teljesen független osztályt, ami a téglalap területét számolja ki, vagy át kéne írnunk ennek az osztálynak az AreaCalculation függvényét. Esetleg megtehetnénk, hogy létrehozunk egy másik függvényt, de ezek az utak nem jók. Már azzal hiba van, hogy az osztályunk neve arra utal, hogy ez egy négyzet, akkor hogyan számolhatna téglalap területet. Megtenni megtehetné, de abban a pillanatban megsértenénk az SRP elvet és nagy valószínűséggel a GOF1 elvet is. Jól látszik az, hogy ha sikerül elérnünk azt az állapotot, hogy a felület és a logika egymástól jól elkülönülve legyen, akkor a következő lépés ismét egy tervezés lesz. Ezen a ponton át kell gondolnunk és egy tervet kell készítenünk, hogy miként lehetne ezt tovább fejleszteni úgy, hogy a fenti elveket ne sértsük meg. Ha megvan a terv, akkor a TDR módszerrel ismét nekieshetünk a refaktorálásnak.

##A terv

**Egy élő kód állandóan változik.** Ez a fő elvünk. A folyamatos változást az új igények, illetve a megváltozott igények kényszerítik ki. Az új igényekhez új tervek kellenek. Ennek a rugalmas rendszernek a fejlesztéséhez többféle fejlesztési módszertant választhatnánk. Itt mi most egy leegyszerűsített iteratív módszert alkalmazunk. A lényege az, hogy van egy adott igényünk, amihez tervet készítünk majd a tervek alapján megvalósítjuk. Konkrétan vesszük a feladat első részét, ehhez készítünk tervet majd megvalósítjuk. Ha ezzel végeztünk, akkor elővesszük a feladat második részét és ahhoz készítünk tervet majd valósítjuk meg. A két feladat két külön igény, vagyis minden igényt külön megtervezünk és megvalósítunk. Megtervezhettük volna az egészet egyszerre és lehet, hogy jobban jártunk volna, de a *valóság az, hogy az igények rendszerint nem egyszerre jönnek*. Jellemzően hullámokban érkeznek. Ezért maximum hullámokban tervezhetünk. Erre jó az iteratív módszertan. De nem csak ezért érdemes így tervezni. *Minden fejlesztési terv legfeljebb akkora lehet amekkora fejlesztést két verió között végre tudunk hajtani.* Ha két hetes ciklusokban fejlesztünk, akkor két hétnél tovább nem célszerű tervezni csak akkor, ha egy nagyon specifikált feladattal állunk szemben, ami biztos, hogy nem fog változni a jövőben. Nem lesznek új igények és a tervek már elsőre úgy sikerültek, hogy azon változtatni nem kell, a megvalósítás során nem jönnek elő olyan problémák amik miatt a terveken változtatni kell. Ilyen merev feladat még ha létezik is, képtelenek vagyunk ennyire mereven megvalósítani. Ennek egyszerűen az az oka, hogy emberek vagyunk és hibázni fogunk. Természetesen átfogó, fejlesztési ciklusokon átnyúló rendszertervnek létezni-e kell, de az csak a fejlesztés medrét határozhatja meg. Megmondja, hogy a rendszer milyen részekből épül fel, milyen eszközöket használunk fel hozzá stb., de nem mondhatja meg, hogy mi legyen a kódban. Ez a fejlesztési terv része, ami nem nyúlhat át a fejlesztési ciklusokon.
Tervezésnél a továbbiakban a lehető leg általánosabb megoldásokat próbáljuk meg előtérbe helyezni. Abból indulunk ki, hogy egy olyan alapot tegyünk le, amit nagyon könnyű tovább fejleszteni (a későbbi katákba ezt majd meg is tesszük). Mondhatnánk azt, hogy a négyzetben és a téglalapban a közös az, hogy derékszögű négyszögek, ha általánosabban fogalmaznánk, akkor négyszögek, de ha már így gondolkodunk, akkor igazából sokszögek. Ha még ettől is általánosabban gondolkodunk, akkor egyszerűen alakzatok.

###Alakzatok terve

A tervhez ismernünk kell a megvalósítandó logikát. A logika a sokszögek területszámítása. Ezzel a tudománnyal a geometria foglalkozik. Ahhoz, hogy egy jó tervünk legyen szükségünk van bizonyos fokú geometriai tudásra. Szerencsére itt nekünk most elég egy nagyon alap tudás. Mi is a közvetlen feladatunk? Számoljuk ki valamely alakzat területét. Az alakzat síkbeli és négyzet vagy téglalap lehet. Abban viszont nem lehetünk biztosak, hogy a későbbiekben nem lesz szükségünk más síkbeli alakzatokra. Bár nem fogjuk lefejleszteni a rombusz vagy trapéz vagy egyéb sokszög területszámítását, mert itt ez most nem feladat, de úgy kell megterveznünk a programunkat, hogy a későbbiekben, ha szükség van rá, akkor azt minden gond nélkül megtehessük, mint ahogyan azt is, hogy ne csak terület, hanem például kerület számításra vagy más az SRP elvet nem sértő szolgáltatás lefejlesztésére is alkalmassá tehessük az adott kódrészt. Ezzel a gondolkodásmóddal lefektetjük az utat az OCP előtt. Másféle gondolkodásmód nem fogja biztosítani azokat a feltételeket, amitől az OCP elv betartása a kódunkban könnyen járható út marad. Márpedig az OCP elv betartása nélkül a kódunk előbb-utóbb spagetti kód lesz.
Jelenleg síkbeli alakzatokon gondolkodunk. Ez egy kétdimenziós alakzat. És ha egy vagy több dimenziós alakzatot szeretnénk? Ez már egy érdekes kérdés. Kell-e egy programot ennyire általánosra tervezni? Ok, hogy nem fogjuk lefejleszteni, de szükségünk van-e arra, hogy ennyire komoly tervet tegyünk le az asztalra, ami akárhány dimenziós alakzatokat képes kezelni. Erre nincs egyértelmű válasz. Ha nagyon általánosra tervezzük, akkor mind a tervezés mind a megvalósítás sok időt visz el, cserébe könnyű lesz továbbfejleszteni. Nem tehetünk mást ilyenkor, csak mérlegelünk, hogy mi mennyit ér. Ahogy láttuk a példában a logikai részünk amikor még a felületen volt csak egy változó megszorzása önmagával. Ha tényleg csak ennyi kell, akkor minek kell elbonyolítani. Ha kell egy téglalap számítás is, akkor csak megírunk még egy programot, szintén egy soros logikával. Ha kell kör vagy téglatest vagy bármi más, akkor azokhoz is megírunk egy nagyon egyszerű kis programot. Ezek a kódok viszont nem lesznek újrahasznosíthatók, nem lehet a végén azt mondani, hogy egy jól megtervezett felülettel az összes tudást vagy a tudásnak valamely részét beépítjük egy felhasználói programba vagy többe. Ha így gondolkodtak volna a GeoGebra fejlesztői, soha nem készültek volna el a programmal, de szerencsére nem így gondolkodtak. Az én véleményem az, hogy *ha gyorsan kell elkészíteni egy szoftvert és a szoftver az elkészítése után biztosan megy a szemétbe, akkor nincs értelme nagyobb tervnek mint ami pontosan az adott igényt fedi le. Minden más esetben viszont a jól megtervezett utat szabad csak járni.* Hogy konkrét példát is írjak, ne próbálj vizsgán egy területszámítást úgy megírni ahogyan itt fogjuk, mert nem lesz rá időd és semmi szükség rá, ha a feladat tényleg csak annyi, hogy számítsd ki egy négyzet területét. A kód amit leadsz eldobható, mert leadod, értékelik és azzal megy a kukába. Vannak még ilyen helyzetek, de ha olyan programot írsz, amit hosszú távú használatra tervezel akkor valóbban tervezzél. A hosszú távú használat az általában azt jelenti, hogy több ember számára publikálod. Ez már hosszú távú használat, még ha elsőre nem is tűnik annak. 
Itt mi most egy olyan tervet készítünk, ami dimenziófüggetlenné teszi a kódot. Tesszük ezt azért, hogy gyakoroljunk, de akár azt is írhattam volna, hogy felkészülünk egy újabb igényhullámra (ami majd jönni is fog a következő katákban).
Nézzük az alakzatok mit igényelnek. Van egy pontunk. Ez a legegyszerűbb alakzat. Jelenleg nincs rá szükségünk, de most csak tervezünk. Tudjuk azt, hogy ki is kell majd tudni rajzolni. Rajzoláshoz viszont koordinátákra van szükség. Ha koordináta rendszerbe helyezzük, akkor két dimenzió esetén egy x és egy y koordináta írja le a pontot, ha három dimenzióba, akkor x, y és z. Ha egyenest veszünk, akkor tudjuk, hogy az egyenest két pont határoz meg. A pontról viszont már tudjuk, hogy mi. Ha háromszöget, akkor három pont. És így tovább. A lényeg, hogy az alakzatok adatai a pontok. Csak ennyire van szükségünk, hogy minden további adatot kiszámolhassunk. Ez az a közös rész, amivel minden alakzat leírható. Minden más csak adott alakzatra jó. Egy háromszöget a szögek méretével is meghatározhatunk és még sokféle képen. De a szögekkel nincs mit kezdjünk egy pont vagy egy egyenes esetében, mint ahogyan egy kör esetében se. Látszólag mintha a kör kilógna a sorból, pedig ha a definíciójára visszagondolunk - 'azon pontok halmaza' - akkor máris láthatjuk, hogy a kört is gyakorlatilag két pont már képes meghatározni (hát még a körlapét). 
Megértettük a logikai részt, így már tudunk tervezni. Ez nagyon fontos volt! **Ha nem jó a terv, használhatsz bármilyen elvet és patternt, az eredményed se lesz jó.** Itt mi most úgy néz ki, hogy találtunk egy jó megoldást a logikai részre, ami kellően általános. De ez csak azért van így, mert a megvalósítandó logika nagyon egyszerű, ahogyan már írtuk, egy négyzet területe. Még ennél az egyszerű logikánál is jól látható, hogy a logika átlátása és megtervezése nagyon nehéz feladat. A legtöbb programozó ezen vérzik el, ha ehhez még az a hiányosság is társul, hogy nincs tisztában az elvekkel, akkor szinte biztosan garantált a spagetti kód.
A továbbiakban csak az igényeket fogalmazzuk meg, ami alapján elkészül a teszt, amit majd a kód írás követ, hogy kissé tömörítsük a leírást, de természetesen továbbra is betartjuk a TDD és TDR szabályokat, attól függően, hogy új részt fejlesztünk vagy már meglévőt refaktorálunk. Ez utóbbi a Square osztály átalakításánál lesz szükséges. 
Itt azt is észre lehet venni, hogy stratégia tervezési mintát is használhatnánk, hiszen alakzatokhoz akarunk területszámító stratégiákat megírni. De nem ezt tesszük. Ennél a példánál még csak a GOF, SRP és OCP elvek használatát gyakoroljuk, csak azt próbáljuk megnézni, hogy ezek betartásával mit nyerünk, mekkora erő van pusztán ebben a pár elvben. Stratégia mintához kata majd a pattern mappába lesz. Tehát a megoldás egyedi lesz, nem épül ismert tervezési mintára, szándékosan és ez a szándék majd fontos lesz a későbbiekben, amikor is szintet lépünk, hogy pucér szakácsok lehessünk, de addig még sok XP-t kell összegyűjtsünk és sok katát kell begyakoroljunk.
Kezdjük el ennek a lefejlesztését.
- Mivel szükségünk van pontokra, ráadásul rugalmasan kezelve a dimenziókat, ezért megkövetelünk egy Point osztályt. Ilyen osztály már létezik, több is. Van a System.Windows névtérben vagy a System.Drawing névtérben, de ezek nekünk nem jók. Léteznek más osztályok, amiket felhasználhatnánk, de most a gyakorlás kedvéért mi magunk valósítjuk meg.
 - Megkövetelünk egy konstruktort hozzá, ami paraméterben várja a dimenziónak megfelelően az egyes tengelyekhez az értékeket.
 - Megkövetelünk egy GetDimensionsValues függvényt, ami visszaadja az értékeket.
 - Megköveteljük, hogy a konstruktor paraméterének jövőbeni változásai ne befolyásolják a pont objektumot.
 - Megköveteljük, hogy a GetDimensionsValues függvény visszaadott értékén keresztül ne tudjunk a pont értékeihez hozzáférni.
 - Igényt támasztunk egy Shape absztrakt osztályra, ami az alakzatok őse lesz. **Absztrakt osztályt nem tudunk tesztelni, csak akkor, ha a leszármaztatjuk a teszt projektben, ezért nem tűnik egyértelműnek, hogy TDD esetén ezt kell-e tesztelni. Kell! Főleg akkor, ha implementáció is van az absztrakt osztályban**, mint esetünkben. Megírjuk a tesztet, ami kikényszeríti a Shape absztrakt osztály megírását.
 - Kikényszerítjük, hogy a konstruktor paraméterét kötelező megadni, vagyis nem lehet null.
 - Engedjük-e meg egy alakzatnak, hogy 0 dimenziós legyen? Hülyeségnek tűnik egy 0 dimenziós alakzat, főleg, ha ki kell rajzolni. Persze egy 0 dimenziós alakzat területszámításával is problémáink lesznek. De ugyanígy egy 3-tól több dimenziós alakzat is furcsa lehet. De ha belegondolunk és a 4-dik dimenziónak az időt vesszük fel, akkor mozgó alakzatokat hozhatnánk létre. De akkor már nem lenne jó a konstruktor paramétere, az ugyanis nem időt, hanem pontot vár. Vagyis ezt nem tudnánk lekezelni. A programunk alkalmas lehet a későbbiekben alakzatok mozgatására, de ahhoz más osztályokat és további terveket kell készíteni. Nekünk itt ilyen feladatunk nincs. A fentiekből az következne, hogy korlátozzuk a dimenziókat 1 és 3 közzé, de ezt nem teszem meg. A feladatunkat ettől függetlenül is el tudjuk végezni, és akkor miért korlátozzunk. Lehet, hogy létezik a 0 dimenziós alakzat (elképezlni nem tudom az milyen lehet) vagy a 12 dimenziós, ahol 12 pont határozza meg a dimenziót, de ez csupán annyit jelent, hogy én nem tudok ezekről. *Ha rugalmas kódot akarunk, akkor használjuk szabálynak azt, hogy nem korlátozunk, csak ha feltétlenül szükséges.* Tehát kikényszerítjük, hogy 0 dimenziós és 0-tól nagyobb dimenziós alakzatokat is elfogadjon az alap alakzat osztályunk. Kikényszerítjük ezt egy érdekes teszttel. Nem mindenki tartja szabályosnak azt a teszt módszert, hogy véletlenSZERŰ számokkal teszteljünk, de nekünk ide tökéletes. Csak annyit kell tegyünk, hogy, ha gond van, akkor a hibaüzenetbe is kiírjuk, hogy éppen hány dimenziós teszt futott. Így válik megismételhetővé a teszt probléma esetén. Annyit azért megteszünk, hogy max 100 dimenziót hozzunk létre, mert a memória véges. Int.Max esetén biztos megtöltenénk a memóriát. 
 Mit nyerünk ezzel? Vannak esetek, amikor utólag olyan kód készülhet el, ahol valamilyen oknál fogva ráprogramoznak egy konkrét esetre. Volt szerencsém már ilyennel találkozni. Minden esetet nem tudunk letesztelni, de legalább egy minimális esélyt adunk annak, hogy ha valaki garázdálkodna a kódba, akkor azt előbb vagy utóbb (inkább utóbb) elkaphassuk.
 - Az absztrakt osztályban csak azt valósítjuk meg ami minden alakzat osztályhoz kell. Tudja visszaadni az alakzatokat leíró pontok halmazát. Kikényszerítünk egy GetPoints függvényt. A tesztjeinket átírjuk, hogy a GetPoints függvény segítségével fussanak. Csak így érjük el a pontokat, csak így tudjuk tesztelni. A másik megoldás, hogy konténerosztályt készítünk az alakzat osztályból. Itt mi mind a kettőt megvalósítjuk.
 - A pontokat az alakzat a létrejöttekor kapja meg, vagyis kikényszerítünk egy konstruktort, amiben megkapjuk az alakzatok tömbjét.
 - Az alakzatot a bemenő paramétertől függetlenné tesszük. Kikényszerítjük, hogy a bemenő objektum változása ne befolyásolja az alakzat későbbi működését.
 - Kényszerítsük ki a Shape konstruktoránál, hogy a paraméterekben megkapott pontok csak azonos dimenzióbeli pontok lehetnek. Ha nem azonosak, akkor az alakzatot nem engedjük példányosítani. Ehhez viszont előbb ki kell kényszerítsük, hogy a Point osztály tudja visszaadni egy függvénnyel, hogy ő mekkora, vagyis kikényszerítünk a Point osztályba egy Dimension propertyt.
Az alábbi részt már az adott tervezési ciklusban el kell döntsük, de szándékosan ide lett leírva, mert a probléma ezen a részen merül fel, ha nem terveztünk megfelelően. Lássuk mi is a gond.
Logikus megoldásnak tűnhet négyzetből leszármaztatni a téglalapot, hiszen a négyzetnek egy oldalát kell megadni, míg a téglalapnak 2 oldalát. Ha csak ezt a két alakzatot nézzük, akkor ez is egy logikus megoldás lehet programozási szempontból. Míg a négyzet megkapja konstruktorban az a oldal értékét, addig a téglalap a négyzetből leszármaztatva megkapja a konstruktorban az a és a b oldalak értékét, majd az a értékét tovább is adja a négyzet konstruktorának. Egy ettől eltérő kifejtést találunk a Programozási technológiák jegyzetben (Programozási technológiák, A program kódja állandóan változik, Kusper Gábor, Eger, 2015) az LSP elv kifejtésénél (95. old). A jegyzetben ez szerepel: "négyzet olyan speciális téglalap, ahol az oldalak egyenlő hosszúak. Szinte adja magát, hogy ... a négyzet a téglalap alosztálya legyen." Ez a példa is terület számításával foglalkozik. Ugyanaz a téma, ráadásul nagyon egyszerű téma. Négyzet és téglalap területszámítása. Mégis 2 teljesen különböző gondolatmenet. Ezek alapján az az érzésünk támadhat, hogy ***maximum csak annyira jó programot tudunk írni, amennyire a logikai részt átlátjuk és megértjük***. Ez nyelv független. Sőt itt még elv és tervezési minta se számít, hiszen még csak a logikai részt próbáljuk megérteni. Ez pedig még csak matematika és itt a csak nem a matematikának szól, hanem a végrehajtandó feladatnak. Még csak a logikai résznél tartunk, még azt se láttuk át teljesen. **A logikai rész megtervezésén áll vagy bukik minden, már az elején.** 
Egy program írása hasonló egy épület építéséhez. Képes-e egy ember tervek nélkül házat építeni? Igen. Persze kell legyen egy kis esze, de a múltban nem igazán volt alkalma egy parasztnak mérnököt hívni, hogy megterveztesse a házát, vagy egy favágónak, hogy a hegyen menedéket építsen magának. Az emberek feltalálták magukat, fejben összeállítottak egy megfelelő tervet és már neki is lehetett kezdeni a munkának. De komoly tervek nélkül nagy épületet építeni lehetetlenség. Elég valószínűtlen, hogy egy Colosseum tervek nélkül megépülhetne. Pontosan ez van a programozásban is. Egy egyszerű konzolos alkalmazást szinte bárki meg tud írni. A kezdeti pár soros kis területszámító programunkat bármely kezdő programozó meg tudja írni. Ezekhez nem kell terv. Csak meg kell írni azt a pár sort és kész. A problémát az okozza, ha egy komolyabb rendszert kell megírni, nem csak egy kis konzolos alkalmazást. A tervezés bemutatása itt most nem feladat, csupán a jelentősége lett kiemelve. Térjünk vissza a feladatra.
Mivel mi fent már döntöttünk, hogy azt a logikát követjük, hogy egy alakzatot pontok határoznak meg, ezért a fentebb vázolt gondolatok helytelen utakra visznek. Egy négyzetet négy ponttal tudunk leírni, egy téglalapot is, akárcsak bármely más négyszöget. Akkor is ha síkban van és akkor is ha térben. Mondhatnánk azt, hogy minden alakzatot a Shape osztályból származtassunk és legyenek egymástól függetlenek. Ha a logikai részt nem értjük, akkor ez egy nagyon jól járható út. A kód rugalmas lesz, cserébe minden alakzatot külön kell megvalósítani. Ha nem akarunk minden alakzatot teljes egészében külön megvalósítani, akkor tanulmányoznunk kell a logikai problémát, hogy megtaláljuk az összefüggéseket. Négyszögek esetén a terület számításról azt tudjuk, hogy alap szorozva magasság. Más összefüggések is léteznek. Olyan összefüggések, amik például négyszögek és háromszögek között állnak fent(!!!). Mi most a következő logikát valósítjuk meg: van az alakzat, belőle származtatjuk a négyszöget, abból pedig a négyzetet és a téglalapot és szükség esetén bármilyen más konkrét négyszöget. A terület számítást pedig rábízzuk a lánc végére. Mindenképpen rugalmas megoldás, de nem éppen optimális. Ettől függetlenül most ezt valósítjuk meg, hogy egy későbbi katába rávilágíthassunk a hibánkra (fentebb az a három felkiáltójel nem véletlenül került oda).
Ennél a sok leszármaztatásnál van még egy megvizsgálandó probléma. Sértjük-e a GOF2 elvet? Itt most azt kell átgondolni, hogy elképzelhető-e az, hogy az alakzat és a négyszög közzé be szeretnénk-e szúrni egy köztes osztályt vagy a négyszög és a derékszögű négyszögek közzé, esetleg a derékszögű négyszög és a négyzet vagy téglalap közzé. Ha nem lesz ilyen, akkor a merevségünk nem fog problémát okozni, különben a későbbiekben nagyon megbánjuk.
Akkor haladjunk tovább ezen a gondolatmeneten.
 - Kényszerítsük ki a Quadrilateral absztrakt osztályt, ami a Shape osztályból származik. Azért absztrakt, mert ez is csak egy gyűjtőosztály, legalábbis ebben a katában még ezt gondoljuk, amit majd bánni is fogunk egy későbbi katánál.
 - Kényszerítsünk ki egy konstruktort ami pontosan négy pontot kap.
 - Szintén célszerű, már csak a teszt megkönnyítésére is, hogy a négyszöget alkotó 4 pontot le tudjuk kérni. Ezeket akár el is nevezhetnénk A, B, C és D pontoknak.
Van még elhárítandó akadály. A területszámító függvényünk oldalhosszúságot kap, nem pedig a négyszögek pontjait. Az biztos, hogy szükségünk lesz egy függvényre, ami képes kiszámolni 2 pont közötti távolságot. Ez viszont dimenziófüggetlen kell legyen, helyesebben mondva minden dimenzióhoz külön meg kéne írni. Nekünk viszont csak 2 dimenziós alakzataink vannak most, ezért elég csak ezt megvalósítani. A kérdés már csak az, hová tegyük ezt a függvényt. Logikusnak tűnik, hogy a Shape osztályba, hiszen minden alakzatnál szükség lehet az alakzat bármely 2 pontja közötti távolság kiszámítása.
 - Kikényszerítünk egy Distance függvényt a Shape osztályban, ami paraméterként 2 indexet vár, az alakzatot alkotó pontok halmazából. Itt most megint használhatnánk távolság számító stratégiát az egyes dimenziókhoz, de továbbra is egyedi megoldást alkalmazunk és egy egyszerű swich elágazással oldjuk majd meg a problémát.
 - Kikényszerítünk a Shape osztályba egy GetDimension függvényt, hogy ezzel ki tudjuk majd szolgálni a swich elágazást.
 - Kikényszerítjük a Distance függvénytől, hogy a megfelelő hibát dobja, ha olyan dimenzióbeli alakzattal állunk szemben amihez nincs kidolgozva távolságszámítás.
 - Kikényszerítjük a Distance függvénytől, hogy a megfelelő hibát dobja, ha a paraméterben megadott indexek nem létező elemre mutatnak.
 - A Distance függvénynek működnie is kéne, ezért kikényszerítjük, hogy megfelelő eredményt adjon vissza. Ehhez a következő tételt alkalmazzuk: ha adott a koordináta-rendszerben az A(a1;a2) és B(b1;b2) pontok, akkor a két pont távolsága egyenlő a két pont megfelelő koordináták különbségeinek négyzetösszegéből vont négyzetgyökével.
 - A következő lépés az lenne, hogy kikényszerítjük a Square osztályt, de ezt nem kell megtennünk, hiszen ez már létezik. Akkor most kellene nekünk valami olyan statikus függvény, aminél, ha oldalhosszúságot adunk meg, akkor legyártja nekünk a négyzet példányt. Ennek érdekében kikényszerítünk egy CreateSquare statikus függvényt.
 - Kikényszerítjük, hogy ez a statikus függvény az oldalhosszúság függvényében egy A = (0,0) kezdő koordinátával készítsen egy négyzetet, mégpedig úgy, hogy a további pontoknál a fel, jobbra, le, balra elvet alkalmazza.
 - Kikényszerítjük a megfelelő konstruktort is, de privátra állítjuk. Ha nem ezt tesszük, akkor meg kell írni azokat az ellenőrzéseket is, amik garantálják, hogy csak olyan négy pontot fogadjon el a konstruktor, amik biztosan négyzetet alkotnak. Nem gond a megírása, de már így is rendesen átestünk a ló túloldalára, ezt most nem írjuk meg.
 - Elérkezett a pillanat, hogy az AreaCalculation függvényünket refaktoráljuk, úgy, hogy most már a példány számolja ki a területet. Ez egyben azt is jelenti, hogy nincs szükség oldal paraméterre, ennek értelmében a TestAreaCalculation és TestAreaCalculationOverflowError tesztfüggvényeket átírjuk, hogy paraméter nélkül kelljen hívni őket. 

A feladat további része már nem szorul túl sok magyarázatra. A téglalap területszámítása a négyzet területszámítása alapján könnyen megírható. Kell egy téglalap objektum és ott a statikus gyártó függvény nem egy oldalt, hanem kettőt kap. Egy szabály lehet, hogy fektetett téglalapot használunk. A kirajzolással se lehet probléma. Egy koordinátarendszerben négy pontot összekötni egy egyenessel nem okozhat problémát.

A pár soros programunk helyett lett egy elég összetett több projektből álló program. Az óriási különbség, hogy az első változat tiltakozik a továbbfejlesztés ellen, míg a jelenlegi változatunk könyörög a továbbfejlesztésért.
 
**Megjegyzés: Láthattuk azt, hogy a TDR módszerrel lehetséges egy komoly refaktorálást végrehajtani a kódon és a spagetti kódot szép lassan lecserélni tiszta kódra, úgy, hogy közben végig üzemképes a programunk. Ami nem látszik ebből a példából az egy még ettől is súlyosabb probléma. Itt most szándékosan egy nagyon egyszerű logikai részt valósítottunk meg. Egy négyzet vagy téglalap területének kiszámítása nem egy felfoghatatlan probléma. A valóság azonban az, hogy az esetek 100 százalékában ettől csak bonyolultabb és összetettebb problémákkal fogunk találkozni. Tehát a fenti példában úgy tűnik, hogy a tiszta kód előállításának nehézsége az elvek betartásából és a TDR módszer alkalmazásából adódik. Ez csak azért tűnik így, mert a logikai részünk nagyon egyszerű volt. A fent vázolt elvek alkalmazását és a TDR vagy új projekt esetén a TDD módszer alkalmazását be kell gyakorolni. Ha jó programozó akarsz lenni, akkor fejlesztés közben ez nem okozhat problémát. Az igazi problémákat a logikai részek megértése fogja okozni.** Ha azt mondom, hogy írj meg egy valódi, pilóták oktatására szolgáló repülőgép szimulátort, azt se tudnád, hol kezdj neki. Persze mondhatnánk, hogy ezt egy csapat írja és nem egy fejlesztő, de ezzel csak áltatnád magad. Egy könyvelési program megírásához tisztában kell legyél a könyveléssel bizonyos fokig, egy szimulátor programnál pedig a fizikának bizonyos területeivel. *Nem szaladgálhatsz lépten nyomon ahhoz a szakemberhez, aki ért ehhez. Az igényfelmérés szakaszában ez le kell tisztuljon, hogy a tervezés már a megfelelő mederbe terelje a projektet. A probléma tehát a logikai rész megértésében van. Ha azt nem érted meg jól, akkor bármilyen elvet is alkalmazol, bármilyen módszer alapján fejlesztel, előállhat egy olyan kódhalmaz, ami szép, csak nem arra volt szükség vagy ami nagyon sokszor előfordul, nem pont arra. Ezek pedig sok plusz kört okozhatnak vagy akár a projektet is meghíúsíthatják.* 
Ahhoz, hogy a logikai rész megvalósítását kielégítő kódot meg tudd tervezni át kell lásd a logikai részt. Különben a terved ezer sebből fog vérezni és a kóddal folyamatosan problémák lesznek. A mi példánkban amikor a logikai részt leválasztottuk a felületről, akkor kaptunk egy Square osztályt egy AreaCalculation függvénnyel, aminek a tartalma csak ennyi volt: 'return pSideA \* pSideA;', ahol a pSideA a bemenő paraméter. Ez a kis rész tökéletesen kiszolgálta az éppen aktuális igényt és még az elveket is majdnem mind betartotta, mégis egy továbbfejleszthetetlen rossz kód volt. Akkor és ott nem volt cél az, hogy átlássuk a geometriának ezt a részét és az alapján tervezzünk, ezt a szétválasztás után tettük meg. De ha képtelenek lettünk volna ezt az egyszerű problémát átlátni, akkor ismételten belefutottunk volna hasonló hibákba.
Mindezek mellé van még egy súlyos probléma. Az idő. ***Nem lóghatsz a logikai részeken évekig, amíg képes leszel megérteni, mert a projektek időhöz kötöttek.*** A legtöbb cég nem tud megbirkózni a DOOM IV efektussal, amikor egy másfél-két éves projekt 8 évig elhúzódik. Sok cég az ilyenbe beleroppanna. Természetesen egy id Software képes elviselni ilyesmit, de biztosak lehetünk benne, hogy ők se örültek egy ekkora csúszásnak. A két probléma kéz a kézben jár. Minél rövidebb idő alatt minél jobban kell megérteni a logikai részt, hogy tudj tervezni és a tervekkel már a megfelelő mederbe tartsd a projektet. Se az nem jöhet szóba, hogy nem érted meg kellően a logikai részt a tervezés előtt, se az nem jöhet szóba, hogy évekig próbálod megérteni a feladatot. A legnagyobb erőforrásodat ez veszi el. Ez az ami téged is meztelen séffé tehet. Nem is kérdés, hogy rutin kell legyen a programozás legtöbb trükkje ezen a szinten, mint ahogy az se kérdés, hogy Jamie Olivernek se okoz gondot a konyhába található legtöbb eszköz, a piacon fellelhető legtöbb alapanyag és a szakácskönyvekbe lévő legtöbb konyhai trükk. Pont ezért használhatatlan a legtöbb nagymama recepteskönyve. A rutinnal nem rendelkező embernek nem tudnak mit kezdeni az olyan utasításokkal, hogy "szórd meg egy kis liszttel, amíg félkemény nem lesz". Ehhez már kell a rutin, mint ahogy nekünk programozóknak kellenek például a programozási alapelvek. 
Tehát még egyszer: ***AZ ELVEK ALKALMAZÁSÁT ÉS A TDD VAGY TDR MÓDSZEREK HASZNÁLATÁT SAJÁTÍTSD EL JÓL, HOGY FIGYELNI TUDJ A VALÓDI PROBLÉMÁKRA!***

A bemutatott megoldás természetesen túlzásokba esik. Ahogy fentebb írtuk: "átestünk a ló túloldalára", de pont ez volt a cél. Bár a feladat csak annyi volt, hogy számítsuk ki a négyzet és téglalap területét, addig általánosítottunk, amíg a kódunk nagyon sok irányba tovább fejleszthető. De még mindig nem tökéletes. A következő katába bemutatásra kerül egy olyan megoldás, ami képessé teszi a kódot bármely négyszögű alakzat kirajzolására. 
