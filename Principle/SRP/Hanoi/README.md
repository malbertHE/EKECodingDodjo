SRP (Single Responsibility Principle) - Egy felel≈ëss√©g egy oszt√°ly alapelve

Feladat:
<<<<<<< HEAD
Adott az SRP\Hanoi\Program\MAF.EKE.SRP.HanoiDemo projekt. Ez a projekt egy Hanoi demÛt valÛsÌt meg nÈgy koronggal konzolos fel¸leten. A feladatunk csup·n annyi, hogy Ìrjuk ·t a demÛt ˙gy, hogy a felhaszn·lÛ adhassa meg a korongok sz·mait 1 Ès 15 kˆzˆtt, ahol minden korong szÌne m·s, ill. fekete szÌn˚ nem lehet a korong. Fontos, hogy a konzolon futÛ demÛ tov·bbra is megfelelıen m˚kˆdjˆn (pl. ne essen szÈt a demÛ a konzolos ablakon, ne cs˙sszon ki a l·thatÛ kÈpernyırıl stb.), b·rmilyen sz·mot is ad meg a felhaszn·lÛ a megengedett intervallumban. A feladatunkat nehezÌti, hogy ez egy rothadÛ kÛd vagy m·s nÈven spagetti kÛd. A kÛdot a megfelelı ir·nyba refaktor·l·ssal terelj¸k. FejlesztÈs kˆzben tartsuk be a GOF1, GOF2 Ès SRP elveket.

Ha nem boldogulunk a feladattal, akkor a kˆvetkezı pÈld·t:
 - A Library kˆnyvt·r MAF.EKE.SRP.Hanoi projektje a szolg·ltat·st valÛsÌtja meg.
 - A Program kˆnyvt·r MAF.EKE.SRP.HanoiDemo2 a konzolos kiÌr·st mutatja be.

A HanoiDemo Ès HanoiDemo2 konzolos pÈldaprogramokat hasonlÌtsuk ˆssze, hogy mennyivel lett egyszer˚bb.

Mindenkinek jÛ gyakorl·st!


Ha elsıre nem siker¸lt, ne keseredj el, ink·bb olvasd el az itteni segÌtsÈget, ahol lÈpÈsrıl lÈpÈsre le van Ìrva a feladat megvalÛsÌt·s·nak menete.
Mivel a korongok sz·m·t egy v·ltozÛ t·rolja, ami jelenleg 4-re van ·llÌtva, adn· mag·t a lehetısÈg, hogy Ìrjuk ·t 5-re. Ez viszont egy rothadÛ kÛd, ahogy ezt megprÛb·ln·nk, m·ris szÈtcs˙szna a konzolos ablak. Azt kell ilyenkor Èszrevenni, hogy elengedhetetlen a refaktor·l·s. Ebben a kicsi pÈld·ban ak·r azt is megtehetnÈnk, hogy ˙jraÌrjuk az egÈszet, betartva az elveket, de itt most a refaktor·l·st is szeretnÈnk gyakorolni. Teh·t jˆjjˆn a refaktor·l·s menete: 
 - Az elsı lÈpÈs, hogy a fel¸letet v·lasszuk el a logik·tÛl. Ha az lett volna a feladat, hogy a fel¸letet cserÈlj¸k le grafikus fel¸letre szintÈn nem tudtuk volna megtenni, mert a fel¸let Ès a logika egy oszt·lyban van megvalÛsÌtva. Mi most kÈszÌts¸nk egy kˆnyvt·rt, hogy oda ·t tudjuk majd tenni a logik·t. A fenti megoldott pÈld·ban ez a MAF.EKE.SRP.Hanoi projekt.
 - Ha elkÈszÌtett¸k a logik·t megvalÛsÌtÛ projektet, akkor hozzunk lÈtre benne egy Hanoi oszt·lyt.
 - Hozzuk lÈtre a konstruktort, ami 1 paramÈtert v·r, a korongok sz·m·t, amit elment¸nk egy priv·t mezıbe, de olvas·sra publikuss· tessz¸k (property).
 - Az oszt·ly m˚kˆdÈsÈt tˆbbfÈle kÈppen megvalÛsÌthatn·nk, mi most az egyszer˚sÈg kedvÈÈrt azt a megold·st v·lsztjuk, amikor a konstruktor m·r elıre kisz·molja a lÈpÈseket Ès elt·rolja Ès a tov·bbiakban csup·n inform·ciÛszolg·ltat·st ny˙jt. SzerencsÈre a programunk nem annyira rothatÛ, a logika nagy rÈszÈt 2 f¸ggvÈny vÈgzi el, ezeket fogjuk ·ttenni. Ez a kÈt f¸ggvÈny az eredeti kÛdban a Hanoi Ès a HanoiA. Ezeket ·temelj¸k a logikai rÈszbe.
 - A Hanoi f¸ggvÈnyt ·tnevezz¸k CalcHanoi nÈvre.
 - A f¸ggvÈnek ne legyenek statikusak, a static kulcsszÛt tˆrˆlj¸k.
 - A Tuple oszt·lyok haszn·lat·t meg kell sz¸ntetni. Ez szembe megy a GOF1 alapelvel Ès Bob b·csi se szereti ha egy v·ltozÛnak a nevÈbıl nem der¸l ki, hogy ı mi is pontosan, m·rpedig a Tuple ·ltal egybefogott v·ltozÛkhoz csak tÌpus van megadva vagyis nincs is nev¸k. LÈtrehozzuk a Step oszt·lyt, amivel majd kiv·ltjuk a Tuple oszt·lyt. A Step oszt·ly megvalÛsÌt·s·t megtal·lod a Step.cs f·jlban.
 - A Hanoi.cs f·jlban lecserÈlj¸k a Tuple oszt·lyt mindenhol Step oszt·lyra.
 - A konstruktorban meghÌvjuk a CalcHanoi f¸ggvÈnyt, de a visszatÈrÈsi ÈrtÈkÈt egy priv·t v·ltozÛba elt·roljuk.
 - A CalcHanoi f¸ggvÈny ·ltal kisz·molt Ès priv·t v·ltozÛba mentett list·t publik·ljuk kifelÈ a StepList v·ltozÛban, ami egy IReadOnlyList tÌpus˙ v·ltozÛ. Ezt is tˆbbfÈlekÈppen megoldhattuk volna, mi itt most Ìgy oldottuk meg azt, hogy a priv·t list·hoz ne fÈrjenek hozz·, de azÈrt az adatokat le tudj·k kÈrdezni.
Remek! Eddig a logik·t sikeresen leszakÌtottuk a fel¸letrıl. Ez volt a kˆnnyebb rÈsz. Mivel a HanoiDemo projektbe itt most nem lehet beleÌrni, mert ez maga a feladat, ezÈrt lÈtrehoztam egy HanoiDemo2 projektet a Program mapp·ba, amibe ·tm·soltam a HanoiDemo megvalÛsÌt·s·t Ès Ìgy a tov·bbiakban a HanoiDemo2 kÛdot refaktor·ltam, vagyis a refaktor·lt fel¸let itt tekinthetı meg.
Akkor l·ssuk a tov·bbi lÈpÈseket:
 - A Hanoi Ès a HanoiA f¸ggvÈnyekre m·r nincs sz¸ksÈg itt ezÈrt ezekeet tˆrˆlj¸k, de ez mÈg nem elÈg, mert a Main hivatkozott a Hanoi f¸ggvÈnyre. A HanoiDemo2 referenci·j·hoz hozz·adjuk a MAF.EKE.SRP projektet, majd a Main-beli f¸ggvÈny hivatkoz·s elıtt lÈtrehozzunk egy Hanoi pÈld·nyt, valamint a hivatkoz·st ·tÌrjuk, hogy mostm·r a Hanoi pÈld·nytÛl vegye az adatokat. Ez mÈg mindig nem elÈg a ResultList v·ltozÛnk itt mÈg Tuple tÌpus˙. JavÌtjuk mindenhol, hogy Step tÌpus˙ legyen Ès a ResultList v·ltozÛt tˆrˆlj¸k.
 - Azt tal·ljuk a kÛdban, hogy az ·ltalunk megsz˚ntetett ResultList v·ltozÛt Count ÈrtÈkÈt is felhaszn·lt·k. Ezt javÌthatn·nk ˙gy, hogy a Hanoi pÈld·ny LepesekList·ja v·ltozÛ Count-j·t haszn·ljuk fel, de ezzel megsÈrtenÈnk Demeter tˆrvÈnyÈt, ezÈrt a Hanoi oszt·lyt bıvÌtj¸k ˙gy, hogy legyen LÈpÈsekSz·ma propertyje, ami ezt az adatot adja vissza.
 - Nagyon jÛ, hogy elkÈszÌtett¸k a LÈpÈsekList·ja v·ltozÛt a Hanoi oszt·lyban, de valÛj·ban ezt az oszt·lyt kontÈner oszt·lykÈnt kell haszn·ljuk, ezÈrt kap egy kis kiegÈszÌtÈst.
 - A programunk ismÈt teszi a dolg·t, csak a logikai rÈszt m·r kiszervezt¸k. Viszont a korongok sz·m·t mÈg mindig nem lehet nˆvelni. Ehhez tov·bbi refaktor·l·s sz¸ksÈges, melyekbıl most az kˆvetkezik, hogy a Hanoi pÈld·nyt kitessz¸k priv·t oszt·lyszint˚ v·ltozÛv·, hogy a tˆbbi f¸ggvÈny is elÈrhesse.
 - Kezdj¸k el a Main f¸ggvÈny refaktor·l·s·t. Elıszˆr is a main elejÈn rakjuk rendbe az ablakot. Tˆrˆlj¸k a konzol ablakot, majd Ìrjuk ki, hogy h·ny korongos Hanoi tornyai demÛ fut Èppen.
 - Kezden¸nk kell valamit azzal is, hogy ha fut·s kˆzben ·tmÈretezik az ablakot, akkor szÈtesik minden. Ez ellen kÈtfÈle kÈpen vÈdekezhet¸nk. Vagy letiltjuk az ablak mÈretezhetısÈgÈt, vagy minden kirajzol·sn·l a teljes kÈpernyıt ˙jra rajzoljuk. Mindkettı teljesen m·s megold·st kÌn·l, mi most a kÈpernyı mÈretezÈsÈnek letilt·s·t v·lasztjuk. Ehhez egy kis segÌtsÈg itt tal·lhatÛ: https://social.msdn.microsoft.com/Forums/vstudio/en-US/1aa43c6c-71b9-42d4-aa00-60058a85f0eb/c-console-window-disable-resize?forum=csharpgeneral
 - Hogy a kÛd esztÈtikumon is javÌtsunk a korongokSzama v·ltozÛt refaktor·ljuk numberOfDisks v·ltozÛra.
 - A kÈpernyıt ·trendezz¸k. Bal oldalra kirajzoljuk a korongokat. A kirajzolÛ for ciklust kiszervezz¸k egy DrawDisks f¸ggvÈnybe Ès a f¸ggvÈny hÌv·s·t ·thelyezz¸k kˆzvetlen¸l a cÌmsor kiÌr·s al·.
 - Ahhoz, hogy ismÈt helyesen m˚kˆdı kÛdot kapjunk, kÈnytelenek vagyunk az eddig bal oldalra kiÌrt lÈpÈs inform·ciÛkat megsz¸ntetni. Ezt ideiglenesen kivessz¸k a kÛdbÛl. Majd a kÈsıbbiekben ismÈt sz¸ksÈg lesz r·, kicsit mÛdosÌtva.
 - H˙zunk egy vonalat a disk leÌrÛ rÈsz Ès a demÛ rÈsz kˆzzÈ, hogy kicsit elk¸lˆn¸ljenek. A vonalrajzolÛ rÈszt egyenlıre a DrawDisks f¸ggvÈnybe helyezz¸k.  
Ha most lefuttatjuk a kÛdot, akkor majdnem jÛk vagyunk, lesz·mÌtva h·rom aprÛs·got. Ezeket a kˆvetkezı 3 lÈpÈsben tessz¸k rendbe:
 - Kezdj¸k a demÛ kezdı·llapot·nak felrajzol·s·val. A h·rom r˙d Ès a korongok felrak·sa kezdı ·llapotba rÈszt kiemelj¸k egy f¸ggvÈnybe (DrawInitialState) Ès meghÌvjuk a disk kirajzolÛ f¸ggvÈny ut·n. Ez mÈg nem elÈg, eddig a kirajzol·s statikus volt, de most k¸lˆnbˆzı mÈret˚ diskjeink lehetnek, ezÈrt ennek a f¸ggvÈnynek a m˚kˆdÈsÈt a megfelelı dinamizmussal l·tjuk el.
 - A m·sodik nagy problÈma, hogy mivel a lÈpÈsek kiÌr·s·t kiszedt¸k, ezzel egy¸tt megsz˚ntett¸k a ResultText v·ltozÛ feltˆltÈsÈt is. A Demo f¸ggvÈny viszont sz·mÌt erre. Ideiglenesen a Demo f¸ggvÈnybıl is kiszedj¸k, hogy a program tov·bbra is fusson.
 - A kˆvetkezı probÈma nem is olyan aprÛs·g. Mivel a Demo f¸ggvÈny rekurzÌv, ezÈrt 15 korong esetÈben m·r StackOverflowException hib·t kapunk. Ez is egy intı pÈlda, hogy rekurziÛval csak Ûvatosan. Nek¸nk itt most meg kell sz¸ntetni, teh·t a rekurziÛt ·tÌrjuk ciklusra. Ezt szerencsÈre viszonylag f·jdalom mentesen megtehetj¸k. Miut·n mindezzel vÈgezt¸nk.
Eljutottunk abba az ·llapotba, hogy ismÈt m˚kˆdik a kis bemutatÛprogram, de mÈg sok minden van h·tra. A kÛd mÈg mindig nem jÛ Ès a lÈpÈsek kiÌr·sa is megsz˚nt. A kˆvetkezıkben a lÈpÈsek sz·m·nak ismÈtelt kiÌr·s·t oldjuk meg.
 - Hogy legyen hova kiÌrni, a demÛ rÈszt kicsit lentebb toljuk, hogy a fenti rÈszre legyen hely kiÌrni az aktu·lis lÈpÈst.
 - A rudak fˆlÈ kiÌrjuk mindig az aktu·lis lÈpÈst.
 - A kˆvetkezı lÈpÈs, hogy elindÌtjuk a demÛt. 
 - Hogy a programunk ne legyen ennyire statikus, ·tÌrjuk, hogy a felhaszn·lÛ adhassa meg a korongok sz·m·t a megadott keretek kˆzˆtt (SetNumberOfDisks f¸ggvÈny). Ezt is kiszervezz¸k egy f¸ggvÈnybe, amit a Main elejÈn hÌvunk meg. 
MÈg mindig vannak problÈm·k, folytassuk a refaktor·l·st:
 - A Main f¸ggvÈnyt most m·r szÈpen kitisztÌthatjuk. A SetNumberOfDisks hÌv·s maradhat a Main elejÈn, az InitConsole f¸ggvÈnyt Ès az ut·na kˆvetkezı cÌm kiÌrÛ rÈszt helyezz¸k ki egy InitDrawHanoi f¸ggvÈnybe.
 - A Demo f¸ggvÈnyt nevezz¸k ·t RunDemo f¸ggvÈnyre.
 - Szedj¸k ki a f¸ggvÈny vÈgÈrıl a fˆlˆsleges sortˆrÈst Ès az egykori lÈpÈseket kiÌrÛ rÈszt, amit m·r elızıleg kiremelt¸nk a kÛdba, csak mÈg bent hagytuk amÌg meg nem Ìrtuk az ˙j lÈpÈskiÌrÛt. Mivel az m·r kÈsz erre biztosan nincs sz¸ksÈg¸nk.
 - A Main f¸ggvÈny¸nk most m·r szÈpen olvashatÛ. Egyed¸l az abc tˆmb Èrthetetlen ott. Ezt tegy¸k ·t a RunDemo f¸ggvÈnybe, ˙gyis ı haszn·lja csak.
 - Van mÈg egy olyan hib·nk, hogy ha nagyon kevÈs korongot adunk meg, akkor, mivel az ablak ennek f¸ggvÈnyÈben dinamikus, t˙l kicsi lesz Ès nem fÈr ki a lÈpÈs kiÌr·sa. EzÈrt az oldal minim·lis szÈlessÈgÈt ·llÌtsuk be ˙gy, hogy minden esetben elÈg szÈles legyen.
A programunk m˚kˆdik, a megadott feltÈtelek mellett, de a kÛdunk mÈg nem tiszta! A Main szÈp Ès olvashatÛ, ahogy Bob b·csi szertnÈ, de nÈzz¸k ·t a tˆbbi f¸ggvÈnyt is, mert itt vannak mÈg gondok.
 - A SetNumberOfDisks f¸ggvÈny szintÈn olvashatÛ Ès szÈp, az InitDrawHanoi is, de a DrawDisks f¸ggvÈnyben megjelentek valami m·gikus sz·mok. Ezeket meg kell sz¸ntetni. ⁄gy tudjuk a liter·lokat megsz¸ntetni, ha nevesÌtett konstansokat kÈszÌt¸nk belıl¸k. Ezzel nˆvelj¸k a kÛd olvashatÛs·g·t. Az elsı ilyen m·gikus rÈsz az i*2+1. Ez Ìgy elsıre Èrthetetlen. Tanulm·nyozni kell a kÛdot, hogy ÈrthetıvÈ v·ljon. Ezt nem szabad hagyni, mert az a cÈl, hogy a kÛd minnÈl gyorsabban Ès kˆnnyebben legyen olvashatÛ. Mi is ez az i*2+1? Az i*2+1 a mindenkori korong mÈrete. ⁄gy hat·roztuk meg a korongok mÈretÈt a rajzol·shoz, hogy a korong sorsz·ma hossz˙ legyen a r˙d mindkÈt oldal·n, ill. a rudat is eltakarjuk, ı a + 1. Teh·t ez egy f¸ggvÈny kell legyen. Megadjuk a korong sz·m·t Ès adja vissza a korong mÈretÈt. LÈtrehozzuk a GetDiskSize f¸ggvÈnyt Ès mindenhol a kÛdban ezt haszn·ljuk fel, ah·nyszor csak egy disk mÈretÈt akarjuk meghat·rozni.
 - A kˆvetkezı m·gikus sz·m a 24. Ez gyakorlatilag a konzol sorainak sz·m - 1. Erre nem kÈszÌt¸nk k¸lˆn konstanst, de a konzol sorainak sz·m·ra, ami teh·t 25 igen, egyrÈszt azÈrt, mert tˆbb helyen is felhaszn·ljuk, m·srÈszt azÈrt mert Ìgy olvashatÛbb lesz a kÛd.
 - Most a 15 jˆn. Ez a bal oldalon lÈvı korong inform·ciÛs s·v szÈlessÈgÈnek statikus rÈsze. A dinamikus rÈszÈvel egy¸tt alkotj·k ennek a s·vnak a szÈlessÈgÈt, ezÈrt erre is kÈszÌt¸nk egy f¸ggvÈnyt, DisksInfoBoxWidth nÈven. Õgy ismÈt olvashatÛbb lesz a kÛd.
 - Sokat javult a DrawDisks f¸ggvÈny¸nk, de mÈg nem tˆkÈletes (a tˆkÈletest soha nem Èrj¸k el sehol, de tˆreksz¸nk r·). Ha belenÈz¸nk a f¸ggvÈnybe, akkor kÈt ciklus van benne. Semmi kˆz¸k egym·shoz Ès r·ad·sul tˆbb mint egy m·sodpercig nÈznie kell mÈg egy gyakorlott programozÛnak is, hogy kapcsoljon, vagyis nem olvashatÛ mint egy kˆnyv. …ppen ezÈrt a kÈt ciklust kiszervezz¸k kÈt f¸ggvÈnybe. Az elsıt DrawDisksInfo nÈvvel a m·sodikat pedig DrawSeparatorVerticalLine nÈvvel. A DrawDisks f¸ggvÈny¸nket ettıl olvashatÛbb· m·r nem tehetj¸k, csup·n kÈt f¸ggvÈnyhÌv·s van benne, beszÈdes nevekkel.
 - A DrawSeparatorVerticalLine f¸ggvÈnyben mÈg van egy kis optimaliz·l·si feladatunk. A DisksInfoBoxWidth f¸ggvÈny¸nk ÈrtÈkÈt egy ciklusban kÈrj¸k le. Felesleges minden ciklusban elkÈrni. KÈszÌt¸nk egy segÈdv·ltozÛt amit feltˆlt¸nk a ciklus elıtt Ès azt haszn·ljuk.
 - Kˆvetkezik a DrawInitialState f¸ggvÈny. Itt megint sok dolgunk lesz. Ha megnÈzz¸k a f¸ggvÈny tartalm·t, azt l·tjuk, hogy h·rom jÛl elk¸lˆnÌthetı rÈszbıl ·ll. Az elsı rÈszben m·gia zajlik, sok-sok m·gikus sz·mmal Ès ÈrtÈkad·ssal, elÈggÈ Èrthetetlen mÛdon. Tipikusan ezek azok a rÈszek, amiken egy-egy projekt spagetti kÛdd· Ès egyben kezelhetetlennÈ v·lik. A v·ltozÛk ugyanis oszt·lyszint˚ek, amiket majd m·s oszt·lyok is haszn·lnak. Pl. az f az mi Ès miÈrt 6-osra van be·llÌtva? Egy·ltal·n nem olvashatÛ, mert mi nem m·gusok vagyunk, hanem programozÛk. A m·gusok az egy m·sik kaszt, ık nem programoznak. A teendınk az, hogy ezt a rÈszt rendbetessz¸k. Elsı kˆrben kiemelj¸k a var·zslatos rÈszt egy InitVariables f¸ggvÈnybe. Lehetne neki jobb nevet is adni, ha kital·lunk egyet, akkor egy egyszer˚ refaktor·l·ssal ·tnevezhetj¸k, de most megelÈksz¸nk vele.
 - A m·sodik rÈsz a rudak kirajzol·s·t vÈgzi. Ezt tegy¸k ·t egy DrawRods nev˚ f¸ggvÈnybe.
 - A harmadik rÈsz a korongokat teszi fel kezdı ·llapotba. Ezt egy DrawDisksInitialState f¸ggvÈnybe tessz¸k ki.
 - A DrawInitialState f¸ggvÈny¸nk most m·r szÈp, csak h·rom f¸ggvÈnyhÌv·sbÛl ·ll, de a lÈtrehozott f¸ggvÈnyeken van mit javÌtani. Kezdj¸k az InitVariables f¸ggvÈnnyel. Itt van egy l v·ltozÛ, ami nem is itt kell legyen. Õgy nem is fordul a kÛd. Tegy¸k a helyÈre. EzÈrt cÈlszer˚ v·ltozÛkat ott lÈtrehozni ahol haszn·lj·k ıket Ès nem tˆbb sorral fentebb.
 - Az InitVariables f¸ggvÈny nem nagy viszont teljesen Èrthetetlen. Vannak benne Èrthetetlen nev˚ v·ltozÛk Ès m·gikus sz·mok. Igaz·bÛl annyira spagetti az egÈsz, hogy egy kis ˙jratervezÈst igÈnyel. Ha megnÈzz¸k a h·tralÈvı f¸ggvÈnyek kÛdjait, akkor azt l·tjuk, hogy sz¸ksÈg van a h·rom r˙d x pozÌciÛj·ra. EzÈrt hozzunk lÈtre 3 oszt·lyv·ltozÛt rodXPositionA, rodXPositionB, rodXPositionC nÈvvel Ès inicializ·ljuk ıket a helyes ÈrtÈkkel.
 - A DrawRods f¸ggvÈnyben a SetCursorPosition f¸ggvÈny x pozÌciÛ megad·sahoz ezeket az ˙j v·ltozÛkat haszn·ljuk fel, az ott lÈvı m·gia helyett.
 - A RunDemo mÛdba is fel van haszn·lva az x v·ltozÛ. Itt is a SetCursorPosition f¸ggvÈnyhez haszn·lja olyan m·gi·val ami m·r Èget. A legjobb, ha a ToronyIndex f¸ggvÈnyt lem·soljuk Ès a m·solatot ·tnevezz¸k GetRodPosition-ra, valamint a belsejÈt ˙gy Ìrjuk ·t, hogy m·r ı maga a megfelelı oszlop pozÌciÛt adja vissza. Õgy megsz˚nik a m·gia Ès nem lesz sz¸ksÈg tˆbbÈ az x v·ltozÛra se.
 - Az elıbbi refaktor·l·ssal a d v·ltozÛt is fˆlˆslegessÈ tett¸k. Ezt is kiszedj¸k a kÛdbÛl.
 - Az f v·ltozÛban a rudak tetejÈnek pozÌciÛj·t t·roljuk, vagyis a rudakhoz tartozÛ y koordin·ta felsı ÈrtÈkÈt, ezÈrt ·tnevezz¸k rodTopY-ra.
 - Az InitVariables is olvashatÛ most m·r, kˆvetkezik a DrowRoads. Az elsı amit megtehet¸nk, hogy az A, B, C liter·lokat lecserÈlj¸k, hiszen van is hozz· konstansunk, A, B Ès C nÈven.
 - Az A, B, C nevek nem konstanshoz illıek, ezÈrt javÌtunk rajta Ès c_RodNameA, c_RodNameB Ès c_RodNameC-re nevezz¸k.
 - Azt·n van egy l v·ltozÛnk, ami + 3 + 5 + az egÈsz Ìgy Èrthetetlen ÈrtÈkkel van inicializ·lva. Ez az l a r˙d magass·g·t t·rolja, ezÈrt ·tnevezz¸k rodHeight-re Ès javÌtjuk, hogy csak 1-el legyen magasabb mint a korongok sz·ma.
 - A DrawRods mÈg mindig elÈg nagy, de ha ·tnÈzz¸k a tartalm·t, akkor l·tszik, hogy ı is kÈt rÈszbıl tevıdik ˆssze. EgyrÈszt a rudak nevÈnek kiÌr·s·bÛl, m·srÈszt a rudak kirazzol·s·bÛl, ezÈrt emelj¸k ki ezeket is kÈt f¸ggvÈnybe: WriteRodNames Ès DrawingRods.
 - A DrawDisksInitialState m·r elÈggÈ letisztult, de van benne egy m·gia: i * 2 + 1. Ez nem m·s mint a korong szÈlessÈge, de erre m·r van f¸ggvÈny¸nk, ezÈrt javÌtsuk ezt ki.
 - Van mÈg a RunDemo metÛdus. Itt elsı kˆrben vegy¸k ki a fˆlˆslegesen kikommentezett rÈszeket, m·r nincs sz¸ksÈg r·juk.
 - Itt is megsz¸ntetj¸k a m·gikus sz·mokat.
 - Az abc tˆmbˆt senki m·s nem haszn·lja, ezÈrt behozzuk ide a deklar·ciÛj·t Ès adhatunk neki egy jobb nevet, de itt most mellız¸k, mert nem jut eszembe jobb nÈv.
 - Az oszlopok nevei a logikai rÈszhez tartoznak, ezÈrt azokat is ·ttessz¸k. (Ezt onnan tudhatjuk, hogy ott is haszn·ltuk az 'A', 'B', Ès 'C' neveket.)
 - A ToronyIndex-et ·tnevezz¸k GetRodIndex-re.
 - A RunDemo t˙l nagy, szÈtszedj¸k tˆbb rÈszre. Elıszˆr is az inform·ciÛs szˆveg elejÈnek kiÌr·s·t kitessz¸k egy WriteInfoTextBegin metÛdusba.
 - A lÈpÈsek kiÌr·s·t kitessz¸k egy WriteStepInfo metÛdusba.
 - Az aktu·lis Disk tˆrlÈsÈt kitessz¸k egy ClearActualDisk metÛdusba.
 - A tˆrˆlt korong visszarajzol·sa a megfelelı r˙dra rÈszt pedig kitessz¸k a DrawActualDisk metÛdusba.
 - A RunDemo f¸ggvÈny¸nk most m·r t˚rhetıen nÈz ki, de a kÈt ˙j f¸ggvÈnyen mÈg szÈpÌthet¸nk kicsit. 
 - Optimaliz·ljuk az egÈszet sebessÈgre. Mivel a program kicsi, ezÈrt memÛri·ra fˆlˆsleges optimaliz·lni (nem mintha itt most sebessÈgre t˙l sok Èrtelme lenne, hiszen mÈg v·rakoz·st is beiktatunk, de a pÈlda kedvÈÈrt ezt most megtessz¸k.). Annyit tehet¸nk ez ¸gyben, hogy minden sz·mÌt·st csak egyszer vÈgz¸nk el Ès segÈdv·ltozÛkba t·roljuk ıket. Mivel egyes f¸ggvÈnyek ÈrtÈkeit let·roljuk, sz¸ksÈgtelennÈ bizonyos esetekben maga a f¸ggvÈny, ezÈrt azokat megsz˚ntetj¸k.
 - UtolsÛ lÈpÈskÈnt rakjuk olvas·si sorrendbe a f¸ggvÈnyeket, ahogyan Bob b·csi javasolja, de ezt Èn itt most nem teszem meg, hogy l·thatÛv· v·ljon mennyivel olvashatÛbb lett a Main, vagyis a program.
TermÈszetesen tov·bb lehetne mÈg refaktor·lni, van bıven mit, de mostanra m·r elÈrt¸nk egy viszonylag olvashatÛ Ès kˆnnyen tov·bbfejleszthetı kÛdot. Ha valakinek a kÛdja a vÈgÈre nem Ìgy nÈz ki, nincs semmi gond, sokfÈle utat be lehet j·rni, a lÈnyeg csak annyi, hogy teljesÌts¸k a feladatot.

VÈgeredmÈny:
 Ha a kÈt programot ˆsszehasonlÌtjuk, akkor azt l·tjuk, hogy az eredeti kisebb. Kevesebb sorbÛl ·ll Ès csak egy projektbıl. Ezzel szemben a m·sik a sok f¸ggvÈny Ès kÈt projekt miatt mintha bonyolultabb lenne. De abban a pillanatban, hogy olvasni akarjuk a kÛdok tartalm·t, a refaktor·lt kÛd nagys·grendekkel olvashatÛbb. A f¸ggvÈnyek nevei beszÈdesek, kiolvas·sukkal m·r Èrtj¸k is, hogy mit is csin·l az a f¸ggvÈny. A f¸ggvÈnyek annyira kicsik Ès ·tl·thatÛk, hogy mÈg egy kezdı programozÛ is gyorsan megÈrti azok tartalm·t. Ezen kÌv¸l van mÈg egy nagy elıny. Sokkal gyorsabban tov·bbfejleszthetı. Ebben a pÈld·ban ugyan a logikai rÈsz nagyon kicsi, de mÈg itt is l·thatÛ az, hogy a refaktor·lt kÛd fel¸letÈnek lecserÈlÈsÈvel, (pl. WPF fel¸let), nem sz¸ksÈges a logikai kÛd v·ltoztat·sa. Vagyis a logikai kÛd ˙jrahasznosÌthatÛ, mikˆzben betartja a GOF1, GOF2, Ès SRP elveket. Az eredeti spagetti kÛd viszont haszn·lhatatlan egy WPF-es fel¸lethez, de tov·bbfejlesztÈshez is.

MegjegyzÈs:
 L·thatÛ, hogy folyamatos refaktor·l·ssal egy projekt ˙jraÈpÌthetı, mikˆzben el lehet Èrni azt, hogy p·r lÈpÈsenkÈnt a program tov·bbra is m˚kˆdıkÈpes ·llapotban maradjon. Egy nagy projekt esetÈben ez viszont nem elÈg. A refaktor·l·s akkor j·rhatÛ ˙t, ha mindig elemi v·ltoztat·sokat hajtunk vÈgre. ¡tnevez¸nk egy v·ltozÛt. Kiszervez¸nk egy rÈszt f¸ggvÈnybe, majd egy kˆvetkezı refaktor·l·sn·l ·tÌrjuk stb. De m·r az itteni pÈld·n·l is l·thatÛ az, hogy nem minden esetben j·rhatÛ ez az ˙t. Ha pedig egyszerre bonyolultabb v·ltoztat·sokat hajtunk vÈgre, nem fogjuk tudni, hogy a program mÈg az elv·rt ·llapotban van-e. Hogy ezen t˙llend¸lj¸nk egy ˙jfajta refaktor·l·si mÛdot kell bevezetni, a TDD mÛdszerhez hasonlÛt, a TDR mÛdszert. Ezt majd egy kˆvetkezı pÈldaprogramban nÈzz¸k meg. 
 Fontos mÈg azt is l·tni, hogy a jelen pÈldaprogram mÈretei miatt tal·n ˙gy t˚nik, hogy nincs is Èrtelme ennek a refaktor·l·snak, mert t˙l sok lÈpÈsbıl ·ll. Egyszer˚bbnek t˚nhet az egÈszet gyorsan ˙jraÌrni. Nagy projekteknÈl viszont m·s ˙t j·rhatatlan. Ha valakinek van egy kis tapasztalata, akkor ı m·r jÛl tudja, hogy mekkora problÈma tud lenni, ha napokig vagy hetekig nem fordul le egy program, m·rpedig, ha nem a refaktor·lÛs mÛdszert hasznljuk, akkor kˆnnyen ˆssze lehet hozni nagyobb projekteknÈl. A 20 Èves tapasztalatom mondja ezt.



=======
Adott az SRP\Hanoi\Program\MAF.EKE.SRP.HanoiDemo projekt. Ez a projekt egy Hanoi dem√≥t val√≥s√≠t meg n√©gy koronggal konzolos fel√ºleten. A feladatunk csup√°n annyi, hogy √≠rjuk √°t a dem√≥t √∫gy, hogy a felhaszn√°l√≥ adhassa meg a korongok sz√°mait 1 √©s 15 k√∂z√∂tt, ahol minden korong sz√≠ne m√°s, ill. fekete sz√≠n≈± nem lehet a korong. Fontos, hogy a konzolon fut√≥ dem√≥ tov√°bbra is megfelel≈ëen m≈±k√∂dj√∂n (pl. ne essen sz√©t a dem√≥ a konzolos ablakon, ne cs√∫sszon ki a l√°that√≥ k√©perny≈ër≈ël stb.), b√°rmilyen sz√°mot is ad meg a felhaszn√°l√≥ a megengedett intervallumban. A feladatunkat nehez√≠ti, hogy ez egy rothad√≥ k√≥d vagy m√°s n√©ven spagetti k√≥d. A k√≥dot a megfelel≈ë ir√°nyba refaktor√°l√°ssal terelj√ºk. Fejleszt√©s k√∂zben tartsuk be a GOF1, GOF2 √©s SRP elveket.

Ha nem boldogulunk a feladattal, akkor a k√∂vetkez≈ë p√©ld√°t:
 - A Library k√∂nyvt√°r MAF.EKE.SRP.Hanoi projektje a szolg√°ltat√°st val√≥s√≠tja meg.
 - A Program k√∂nyvt√°r MAF.EKE.SRP.HanoiDemo2 a konzolos ki√≠r√°st mutatja be.

A HanoiDemo √©s HanoiDemo2 konzolos p√©ldaprogramokat hasonl√≠tsuk √∂ssze, hogy mennyivel lett egyszer≈±bb.

Mindenkinek j√≥ gyakorl√°st!


Ha els≈ëre nem siker√ºlt, ne keseredj el, ink√°bb olvasd el az itteni seg√≠ts√©get, ahol l√©p√©sr≈ël l√©p√©sre le van √≠rva a feladat megval√≥s√≠t√°s√°nak menete.
Mivel a korongok sz√°m√°t egy v√°ltoz√≥ t√°rolja, ami jelenleg 4-re van √°ll√≠tva, adn√° mag√°t a lehet≈ës√©g, hogy √≠rjuk √°t 5-re. Ez viszont egy rothad√≥ k√≥d, ahogy ezt megpr√≥b√°ln√°nk, m√°ris sz√©tcs√∫szna a konzolos ablak. Azt kell ilyenkor √©szrevenni, hogy elengedhetetlen a refaktor√°l√°s. Ebben a kicsi p√©ld√°ban ak√°r azt is megtehetn√©nk, hogy √∫jra√≠rjuk az eg√©szet, betartva az elveket, de itt most a refaktor√°l√°st is szeretn√©nk gyakorolni. Teh√°t j√∂jj√∂n a refaktor√°l√°s menete: 
 - Az els≈ë l√©p√©s, hogy a fel√ºletet v√°lasszuk el a logik√°t√≥l. Ha az lett volna a feladat, hogy a fel√ºletet cser√©lj√ºk le grafikus fel√ºletre szint√©n nem tudtuk volna megtenni, mert a fel√ºlet √©s a logika egy oszt√°lyban van megval√≥s√≠tva. Mi most k√©sz√≠ts√ºnk egy k√∂nyvt√°rt, hogy oda √°t tudjuk majd tenni a logik√°t. A fenti megoldott p√©ld√°ban ez a MAF.EKE.SRP.Hanoi projekt.
 - Ha elk√©sz√≠tett√ºk a logik√°t megval√≥s√≠t√≥ projektet, akkor hozzunk l√©tre benne egy Hanoi oszt√°lyt.
 - Hozzuk l√©tre a konstruktort, ami 1 param√©tert v√°r, a korongok sz√°m√°t, amit elment√ºnk egy priv√°t mez≈ëbe, de olvas√°sra publikuss√° tessz√ºk (property).
 - Az oszt√°ly m≈±k√∂d√©s√©t t√∂bbf√©le k√©ppen megval√≥s√≠thatn√°nk, mi most az egyszer≈±s√©g kedv√©√©rt azt a megold√°st v√°lsztjuk, amikor a konstruktor m√°r el≈ëre kisz√°molja a l√©p√©seket √©s elt√°rolja √©s a tov√°bbiakban csup√°n inform√°ci√≥szolg√°ltat√°st ny√∫jt. Szerencs√©re a programunk nem annyira rothat√≥, a logika nagy r√©sz√©t 2 f√ºggv√©ny v√©gzi el, ezeket fogjuk √°ttenni. Ez a k√©t f√ºggv√©ny az eredeti k√≥dban a Hanoi √©s a HanoiA. Ezeket √°temelj√ºk a logikai r√©szbe.
 - A Hanoi f√ºggv√©nyt √°tnevezz√ºk CalcHanoi n√©vre.
 - A f√ºggv√©nek ne legyenek statikusak, a static kulcssz√≥t t√∂r√∂lj√ºk.
 - A Tuple oszt√°lyok haszn√°lat√°t meg kell sz√ºntetni. Ez szembe megy a GOF1 alapelvel √©s Bob b√°csi se szereti ha egy v√°ltoz√≥nak a nev√©b≈ël nem der√ºl ki, hogy ≈ë mi is pontosan, m√°rpedig a Tuple √°ltal egybefogott v√°ltoz√≥khoz csak t√≠pus van megadva vagyis nincs is nev√ºk. L√©trehozzuk a Step oszt√°lyt, amivel majd kiv√°ltjuk a Tuple oszt√°lyt. A Step oszt√°ly megval√≥s√≠t√°s√°t megtal√°lod a Step.cs f√°jlban.
 - A Hanoi.cs f√°jlban lecser√©lj√ºk a Tuple oszt√°lyt mindenhol Step oszt√°lyra.
 - A konstruktorban megh√≠vjuk a CalcHanoi f√ºggv√©nyt, de a visszat√©r√©si √©rt√©k√©t egy priv√°t v√°ltoz√≥ba elt√°roljuk.
 - A CalcHanoi f√ºggv√©ny √°ltal kisz√°molt √©s priv√°t v√°ltoz√≥ba mentett list√°t publik√°ljuk kifel√© a StepList v√°ltoz√≥ban, ami egy IReadOnlyList t√≠pus√∫ v√°ltoz√≥. Ezt is t√∂bbf√©lek√©ppen megoldhattuk volna, mi itt most √≠gy oldottuk meg azt, hogy a priv√°t list√°hoz ne f√©rjenek hozz√°, de az√©rt az adatokat le tudj√°k k√©rdezni.
Remek! Eddig a logik√°t sikeresen leszak√≠tottuk a fel√ºletr≈ël. Ez volt a k√∂nnyebb r√©sz. Mivel a HanoiDemo projektbe itt most nem lehet bele√≠rni, mert ez maga a feladat, ez√©rt l√©trehoztam egy HanoiDemo2 projektet a Program mapp√°ba, amibe √°tm√°soltam a HanoiDemo megval√≥s√≠t√°s√°t √©s √≠gy a tov√°bbiakban a HanoiDemo2 k√≥dot refaktor√°ltam, vagyis a refaktor√°lt fel√ºlet itt tekinthet≈ë meg.
Akkor l√°ssuk a tov√°bbi l√©p√©seket:
 - A Hanoi √©s a HanoiA f√ºggv√©nyekre m√°r nincs sz√ºks√©g itt ez√©rt ezekeet t√∂r√∂lj√ºk, de ez m√©g nem el√©g, mert a Main hivatkozott a Hanoi f√ºggv√©nyre. A HanoiDemo2 referenci√°j√°hoz hozz√°adjuk a MAF.EKE.SRP projektet, majd a Main-beli f√ºggv√©ny hivatkoz√°s el≈ëtt l√©trehozzunk egy Hanoi p√©ld√°nyt, valamint a hivatkoz√°st √°t√≠rjuk, hogy mostm√°r a Hanoi p√©ld√°nyt√≥l vegye az adatokat. Ez m√©g mindig nem el√©g a ResultList v√°ltoz√≥nk itt m√©g Tuple t√≠pus√∫. Jav√≠tjuk mindenhol, hogy Step t√≠pus√∫ legyen √©s a ResultList v√°ltoz√≥t t√∂r√∂lj√ºk.
 - Azt tal√°ljuk a k√≥dban, hogy az √°ltalunk megsz≈±ntetett ResultList v√°ltoz√≥t Count √©rt√©k√©t is felhaszn√°lt√°k. Ezt jav√≠thatn√°nk √∫gy, hogy a Hanoi p√©ld√°ny LepesekList√°ja v√°ltoz√≥ Count-j√°t haszn√°ljuk fel, de ezzel megs√©rten√©nk Demeter t√∂rv√©ny√©t, ez√©rt a Hanoi oszt√°lyt b≈ëv√≠tj√ºk √∫gy, hogy legyen L√©p√©sekSz√°ma propertyje, ami ezt az adatot adja vissza.
 - Nagyon j√≥, hogy elk√©sz√≠tett√ºk a L√©p√©sekList√°ja v√°ltoz√≥t a Hanoi oszt√°lyban, de val√≥j√°ban ezt az oszt√°lyt kont√©ner oszt√°lyk√©nt kell haszn√°ljuk, ez√©rt kap egy kis kieg√©sz√≠t√©st.
 - A programunk ism√©t teszi a dolg√°t, csak a logikai r√©szt m√°r kiszervezt√ºk. Viszont a korongok sz√°m√°t m√©g mindig nem lehet n√∂velni. Ehhez tov√°bbi refaktor√°l√°s sz√ºks√©ges, melyekb≈ël most az k√∂vetkezik, hogy a Hanoi p√©ld√°nyt kitessz√ºk priv√°t oszt√°lyszint≈± v√°ltoz√≥v√°, hogy a t√∂bbi f√ºggv√©ny is el√©rhesse.
 - Kezdj√ºk el a Main f√ºggv√©ny refaktor√°l√°s√°t. El≈ësz√∂r is a main elej√©n rakjuk rendbe az ablakot. T√∂r√∂lj√ºk a konzol ablakot, majd √≠rjuk ki, hogy h√°ny korongos Hanoi tornyai dem√≥ fut √©ppen.
 - Kezden√ºnk kell valamit azzal is, hogy ha fut√°s k√∂zben √°tm√©retezik az ablakot, akkor sz√©tesik minden. Ez ellen k√©tf√©le k√©pen v√©dekezhet√ºnk. Vagy letiltjuk az ablak m√©retezhet≈ës√©g√©t, vagy minden kirajzol√°sn√°l a teljes k√©perny≈ët √∫jra rajzoljuk. Mindkett≈ë teljesen m√°s megold√°st k√≠n√°l, mi most a k√©perny≈ë m√©retez√©s√©nek letilt√°s√°t v√°lasztjuk. Ehhez egy kis seg√≠ts√©g itt tal√°lhat√≥: https://social.msdn.microsoft.com/Forums/vstudio/en-US/1aa43c6c-71b9-42d4-aa00-60058a85f0eb/c-console-window-disable-resize?forum=csharpgeneral
 - Hogy a k√≥d eszt√©tikumon is jav√≠tsunk a korongokSzama v√°ltoz√≥t refaktor√°ljuk numberOfDisks v√°ltoz√≥ra.
 - A k√©perny≈ët √°trendezz√ºk. Bal oldalra kirajzoljuk a korongokat. A kirajzol√≥ for ciklust kiszervezz√ºk egy DrawDisks f√ºggv√©nybe √©s a f√ºggv√©ny h√≠v√°s√°t √°thelyezz√ºk k√∂zvetlen√ºl a c√≠msor ki√≠r√°s al√°.
 - Ahhoz, hogy ism√©t helyesen m≈±k√∂d≈ë k√≥dot kapjunk, k√©nytelenek vagyunk az eddig bal oldalra ki√≠rt l√©p√©s inform√°ci√≥kat megsz√ºntetni. Ezt ideiglenesen kivessz√ºk a k√≥db√≥l. Majd a k√©s≈ëbbiekben ism√©t sz√ºks√©g lesz r√°, kicsit m√≥dos√≠tva.
 - H√∫zunk egy vonalat a disk le√≠r√≥ r√©sz √©s a dem√≥ r√©sz k√∂zz√©, hogy kicsit elk√ºl√∂n√ºljenek. A vonalrajzol√≥ r√©szt egyenl≈ëre a DrawDisks f√ºggv√©nybe helyezz√ºk.  
Ha most lefuttatjuk a k√≥dot, akkor majdnem j√≥k vagyunk, lesz√°m√≠tva h√°rom apr√≥s√°got. Ezeket a k√∂vetkez≈ë 3 l√©p√©sben tessz√ºk rendbe:
 - Kezdj√ºk a dem√≥ kezd≈ë√°llapot√°nak felrajzol√°s√°val. A h√°rom r√∫d √©s a korongok felrak√°sa kezd≈ë √°llapotba r√©szt kiemelj√ºk egy f√ºggv√©nybe (DrawInitialState) √©s megh√≠vjuk a disk kirajzol√≥ f√ºggv√©ny ut√°n. Ez m√©g nem el√©g, eddig a kirajzol√°s statikus volt, de most k√ºl√∂nb√∂z≈ë m√©ret≈± diskjeink lehetnek, ez√©rt ennek a f√ºggv√©nynek a m≈±k√∂d√©s√©t a megfelel≈ë dinamizmussal l√°tjuk el.
 - A m√°sodik nagy probl√©ma, hogy mivel a l√©p√©sek ki√≠r√°s√°t kiszedt√ºk, ezzel egy√ºtt megsz≈±ntett√ºk a ResultText v√°ltoz√≥ felt√∂lt√©s√©t is. A Demo f√ºggv√©ny viszont sz√°m√≠t erre. Ideiglenesen a Demo f√ºggv√©nyb≈ël is kiszedj√ºk, hogy a program tov√°bbra is fusson.
 - A k√∂vetkez≈ë prob√©ma nem is olyan apr√≥s√°g. Mivel a Demo f√ºggv√©ny rekurz√≠v, ez√©rt 15 korong eset√©ben m√°r StackOverflowException hib√°t kapunk. Ez is egy int≈ë p√©lda, hogy rekurzi√≥val csak √≥vatosan. Nek√ºnk itt most meg kell sz√ºntetni, teh√°t a rekurzi√≥t √°t√≠rjuk ciklusra. Ezt szerencs√©re viszonylag f√°jdalom mentesen megtehetj√ºk. Miut√°n mindezzel v√©gezt√ºnk.
Eljutottunk abba az √°llapotba, hogy ism√©t m≈±k√∂dik a kis bemutat√≥program, de m√©g sok minden van h√°tra. A k√≥d m√©g mindig nem j√≥ √©s a l√©p√©sek ki√≠r√°sa is megsz≈±nt. A k√∂vetkez≈ëkben a l√©p√©sek sz√°m√°nak ism√©telt ki√≠r√°s√°t oldjuk meg.
 - Hogy legyen hova ki√≠rni, a dem√≥ r√©szt kicsit lentebb toljuk, hogy a fenti r√©szre legyen hely ki√≠rni az aktu√°lis l√©p√©st.
 - A rudak f√∂l√© ki√≠rjuk mindig az aktu√°lis l√©p√©st.
 - A k√∂vetkez≈ë l√©p√©s, hogy elind√≠tjuk a dem√≥t. 
 - Hogy a programunk ne legyen ennyire statikus, √°t√≠rjuk, hogy a felhaszn√°l√≥ adhassa meg a korongok sz√°m√°t a megadott keretek k√∂z√∂tt (SetNumberOfDisks f√ºggv√©ny). Ezt is kiszervezz√ºk egy f√ºggv√©nybe, amit a Main elej√©n h√≠vunk meg. 
M√©g mindig vannak probl√©m√°k, folytassuk a refaktor√°l√°st:
 - A Main f√ºggv√©nyt most m√°r sz√©pen kitiszt√≠thatjuk. A SetNumberOfDisks h√≠v√°s maradhat a Main elej√©n, az InitConsole f√ºggv√©nyt √©s az ut√°na k√∂vetkez≈ë c√≠m ki√≠r√≥ r√©szt helyezz√ºk ki egy InitDrawHanoi f√ºggv√©nybe.
 - A Demo f√ºggv√©nyt nevezz√ºk √°t RunDemo f√ºggv√©nyre.
 - Szedj√ºk ki a f√ºggv√©ny v√©g√©r≈ël a f√∂l√∂sleges sort√∂r√©st √©s az egykori l√©p√©seket ki√≠r√≥ r√©szt, amit m√°r el≈ëz≈ëleg kiremelt√ºnk a k√≥dba, csak m√©g bent hagytuk am√≠g meg nem √≠rtuk az √∫j l√©p√©ski√≠r√≥t. Mivel az m√°r k√©sz erre biztosan nincs sz√ºks√©g√ºnk.
 - A Main f√ºggv√©ny√ºnk most m√°r sz√©pen olvashat√≥. Egyed√ºl az abc t√∂mb √©rthetetlen ott. Ezt tegy√ºk √°t a RunDemo f√ºggv√©nybe, √∫gyis ≈ë haszn√°lja csak.
 - Van m√©g egy olyan hib√°nk, hogy ha nagyon kev√©s korongot adunk meg, akkor, mivel az ablak ennek f√ºggv√©ny√©ben dinamikus, t√∫l kicsi lesz √©s nem f√©r ki a l√©p√©s ki√≠r√°sa. Ez√©rt az oldal minim√°lis sz√©less√©g√©t √°ll√≠tsuk be √∫gy, hogy minden esetben el√©g sz√©les legyen.
A programunk m≈±k√∂dik, a megadott felt√©telek mellett, de a k√≥dunk m√©g nem tiszta! A Main sz√©p √©s olvashat√≥, ahogy Bob b√°csi szertn√©, de n√©zz√ºk √°t a t√∂bbi f√ºggv√©nyt is, mert itt vannak m√©g gondok.
 - A SetNumberOfDisks f√ºggv√©ny szint√©n olvashat√≥ √©s sz√©p, az InitDrawHanoi is, de a DrawDisks f√ºggv√©nyben megjelentek valami m√°gikus sz√°mok. Ezeket meg kell sz√ºntetni. √ögy tudjuk a liter√°lokat megsz√ºntetni, ha neves√≠tett konstansokat k√©sz√≠t√ºnk bel≈ël√ºk. Ezzel n√∂velj√ºk a k√≥d olvashat√≥s√°g√°t. Az els≈ë ilyen m√°gikus r√©sz az i*2+1. Ez √≠gy els≈ëre √©rthetetlen. Tanulm√°nyozni kell a k√≥dot, hogy √©rthet≈ëv√© v√°ljon. Ezt nem szabad hagyni, mert az a c√©l, hogy a k√≥d minn√©l gyorsabban √©s k√∂nnyebben legyen olvashat√≥. Mi is ez az i*2+1? Az i*2+1 a mindenkori korong m√©rete. √ögy hat√°roztuk meg a korongok m√©ret√©t a rajzol√°shoz, hogy a korong sorsz√°ma hossz√∫ legyen a r√∫d mindk√©t oldal√°n, ill. a rudat is eltakarjuk, ≈ë a + 1. Teh√°t ez egy f√ºggv√©ny kell legyen. Megadjuk a korong sz√°m√°t √©s adja vissza a korong m√©ret√©t. L√©trehozzuk a GetDiskSize f√ºggv√©nyt √©s mindenhol a k√≥dban ezt haszn√°ljuk fel, ah√°nyszor csak egy disk m√©ret√©t akarjuk meghat√°rozni.

Megjegyz√©s:
 - L√°that√≥, hogy folyamatos refaktor√°l√°ssal egy projekt √∫jra√©p√≠thet≈ë, mik√∂zben el lehet √©rni azt, hogy p√°r l√©p√©senk√©nt a program tov√°bbra is m≈±k√∂d≈ëk√©pes √°llapotban maradjon. Egy nagy projekt eset√©ben ez viszont nem el√©g. A refaktor√°l√°s akkor j√°rhat√≥ √∫t, ha mindig elemi v√°ltoztat√°sokat hajtunk v√©gre. √Åtnevez√ºnk egy v√°ltoz√≥t. Kiszervez√ºnk egy r√©szt f√ºggv√©nybe, majd egy k√∂vetkez≈ë refaktor√°l√°sn√°l √°t√≠rjuk stb. De m√°r az itteni p√©ld√°n√°l is l√°that√≥ az, hogy nem minden esetben j√°rhat√≥ ez az √∫t. Ha pedig egyszerre bonyolultabb v√°ltoztat√°sokat hajtunk v√©gre, nem fogjuk tudni, hogy a program m√©g az elv√°rt √°llapotban van-e. Hogy ezen t√∫llend√ºlj√ºnk egy √∫jfajta refaktor√°l√°si m√≥dot kell bevezetni. Ezt majd egy k√∂vetkez≈ë p√©ldaprogramban n√©zz√ºk meg.
>>>>>>> 128ee23d0c62dcae5d28fa5fec0bbb0ee966440d
